23900
((3) 0 () 11 ((q lib "typed-racket/base-env/prims.rkt") (q lib "typed-racket/base-env/base-types.rkt") (q lib "typed/racket/class.rkt") (q lib "typed-racket/base-env/base-types-extra.rkt") (q lib "typed-racket/typed-racket.rkt") (q lib "typed/scheme/base.rkt") (q lib "typed/racket/unit.rkt") (q lib "typed/racket/base.rkt") (q lib "typed-racket/base-env/extra-procs.rkt") (q lib "typed/untyped-utils.rkt") (q lib "typed/racket/unsafe.rkt")) () (h ! (equal) ((c form c (c (? . 1) q Prompt-TagTop)) q (4435 . 2)) ((c form c (c (? . 0) q for/extflvector:)) q (26141 . 2)) ((c form c (c (? . 0) q plet:)) q (25049 . 2)) ((c form c (c (? . 4) q with-type)) q (23766 . 10)) ((c form c (c (? . 1) q Thread-Group)) q (2997 . 2)) ((c form c (c (? . 0) q for/product:)) q (26321 . 2)) ((c form c (c (? . 1) q Continuation-Mark-Keyof)) q (4456 . 2)) ((c form c (c (? . 1) q Nonpositive-Exact-Rational)) q (1516 . 2)) ((c form c (c (? . 0) q define:)) q (25442 . 7)) ((c form c (c (? . 1) q Inexact-Real-Negative-Zero)) q (1303 . 2)) ((c form c (c (? . 0) q for*/flvector:)) q (25803 . 2)) ((c form c (c (? . 2) q define/pubment)) q (17715 . 3)) ((c form c (c (? . 1) q ExtFlVector)) q (3616 . 2)) ((c form c (c (? . 1) q Bytes)) q (2344 . 2)) ((c form c (c (? . 1) q Inexact-Real-Nan)) q (1396 . 2)) ((c form c (c (? . 1) q Inexact-Complex)) q (259 . 2)) ((c form c (c (? . 1) q Negative-Real)) q (1595 . 2)) ((c form c (c (? . 2) q override)) q (18204 . 2)) ((c form c (c (? . 1) q Datum)) q (4394 . 2)) ((c form c (c (? . 1) q Float-Zero)) q (862 . 2)) ((c form c (c (? . 1) q Negative-Flonum)) q (678 . 2)) ((c form c (c (? . 1) q Byte)) q (1668 . 2)) ((c form c (c (? . 1) q Path)) q (2236 . 2)) ((c form c (c (? . 1) q Custodian-Boxof)) q (4134 . 2)) ((c form c (c (? . 1) q Negative-Inexact-Real)) q (1242 . 2)) ((c form c (c (? . 1) q PRegexp)) q (2290 . 2)) ((c form c (c (? . 1) q Flonum-Negative-Zero)) q (779 . 2)) ((c form c (c (? . 3) q List*)) q (3308 . 2)) ((c form c (c (? . 0) q for/or)) q (9330 . 2)) ((c form c (c (? . 1) q Float-Negative-Zero)) q (752 . 2)) ((c form c (c (? . 1) q Struct-Type-Property)) q (2716 . 2)) ((c form c (c (? . 3) q Parameter)) q (26596 . 2)) ((c form c (c (? . 1) q Path-String)) q (3185 . 2)) ((c form c (c (? . 1) q Ephemeronof)) q (4252 . 2)) ((c form c (c (? . 1) q Float-Positive-Zero)) q (807 . 2)) ((c form c (c (? . 0) q inst)) q (13799 . 3)) ((c form c (c (? . 1) q Nonnegative-Real)) q (1571 . 2)) ((c form c (c (? . 0) q for*/hash)) q (9724 . 2)) ((c form c (c (? . 1) q Place)) q (3035 . 2)) ((c form c (c (? . 1) q Positive-Float)) q (560 . 2)) ((c form c (c (? . 1) q Flonum-Nan)) q (916 . 2)) ((c form c (c (? . 1) q Single-Flonum-Positive-Zero)) q (1095 . 2)) ((c form c (c (? . 1) q Identifier)) q (4315 . 2)) ((c form c (c (? . 0) q lambda)) q (7754 . 26)) ((c form c (c (? . 1) q BoxTop)) q (3415 . 2)) ((c form c (c (? . 4) q Cookie)) q (14981 . 2)) ((c form c (c (? . 0) q case-lambda:)) q (24826 . 2)) ((c form c (c (? . 1) q Byte-Regexp)) q (2305 . 2)) ((c form c (c (? . 1) q Symbol)) q (2149 . 2)) ((c form c (c (? . 3) q Class)) q (18362 . 17)) ((c form c (c (? . 4) q URL)) q (15083 . 2)) ((c form c (c (? . 1) q FSemaphore)) q (3086 . 2)) ((c form c (c (? . 0) q define-type-alias)) q (26387 . 2)) ((c form c (c (? . 1) q Struct-Property)) q (6938 . 2)) ((c form c (c (? . 5) q require/typed)) q (26639 . 12)) ((c form c (c (? . 1) q Promise)) q (4043 . 2)) ((c form c (c (? . 0) q for*/hasheqv:)) q (25906 . 2)) ((c form c (c (? . 1) q Impersonator-Property)) q (2744 . 2)) ((c form c (c (? . 0) q for/product)) q (9461 . 2)) ((c form c (c (? . 0) q declare-refinement)) q (27114 . 2)) ((c form c (c (? . 1) q True)) q (2095 . 2)) ((c form c (c (? . 1) q Channelof)) q (3907 . 2)) ((c form c (c (? . 1) q Positive-Inexact-Real)) q (1181 . 2)) ((c form c (c (? . 1) q Negative-ExtFlonum)) q (1920 . 2)) ((c form c (c (? . 1) q Real-Zero)) q (1640 . 2)) ((c form c (c (? . 1) q Flonum-Zero)) q (880 . 2)) ((c form c (c (? . 0) q lambda:)) q (24209 . 6)) ((c form c (c (? . 0) q plambda:)) q (24398 . 3)) ((c form c (c (? . 0) q let)) q (7098 . 13)) ((c form c (c (? . 0) q for/lists:)) q (26272 . 2)) ((c form c (c (? . 6) q invoke-unit)) q (19846 . 3)) ((c form c (c (? . 3) q Row)) q (19165 . 2)) ((c form c (c (? . 0) q popt-lambda:)) q (24727 . 3)) ((c form c (c (? . 3) q Tuple)) q (26583 . 2)) ((c form c (c (? . 0) q for/lists)) q (10590 . 4)) ((c form c (c (? . 7) q values)) q (26625 . 2)) ((c form c (c (? . 1) q Immutable-HashTable)) q (3718 . 2)) ((c form c (c (? . 0) q for/fold)) q (10695 . 7)) ((c form c (c (? . 1) q Syntax-E)) q (4347 . 2)) ((c form c (c (? . 2) q public)) q (18121 . 2)) ((c form c (c (? . 2) q private)) q (18289 . 2)) ((c form c (c (? . 1) q ExtFlonum-Positive-Zero)) q (2006 . 2)) ((c form c (c (? . 0) q for/last:)) q (26238 . 2)) ((c form c (c (? . 0) q for*/first)) q (10523 . 2)) ((c form c (c (? . 5) q require-typed-struct)) q (27086 . 2)) ((c form c (c (? . 1) q Nonnegative-ExtFlonum)) q (1891 . 2)) ((c form c (c (? . 3) q Parameterof)) q (3999 . 3)) ((c form c (c (? . 4) q #%module-begin)) q (14865 . 2)) ((c form c (c (? . 1) q Exact-Imaginary)) q (320 . 2)) ((c form c (c (? . 4) q SSL-Verify-Source)) q (15240 . 2)) ((c form c (c (? . 1) q Byte-PRegexp)) q (2324 . 2)) ((c form c (c (? . 1) q Continuation-Mark-Set)) q (2447 . 2)) ((c form c (c (? . 1) q Exact-Nonnegative-Integer)) q (449 . 2)) ((c form c (c (? . 0) q define-struct/exec:)) q (25728 . 2)) ((c form c (c (? . 0) q for*/list:)) q (25945 . 2)) ((c form c (c (? . 1) q Nonpositive-Fixnum)) q (1822 . 2)) ((c form c (c (? . 1) q Bytes-Converter)) q (2791 . 2)) ((c form c (c (? . 3) q Self)) q (6967 . 2)) ((c form c (c (? . 1) q Syntax)) q (4333 . 2)) ((c form c (c (? . 3) q Mutable-Vector)) q (3568 . 2)) ((c form c (c (? . 6) q unit-from-context)) q (21648 . 2)) ((c form c (c (? . 0) q provide:)) q (13692 . 2)) ((c def c (c (? . 0) q default-continuation-prompt-tag)) q (14773 . 3)) ((c form c (c (? . 6) q define-compound-unit)) q (21050 . 5)) ((c form c (c (? . 1) q Complex)) q (57 . 2)) ((c form c (c (? . 4) q for/extflvector)) q (15263 . 2)) ((c form c (c (? . 1) q EOF)) q (2436 . 2)) ((c form c (c (? . 1) q Custodian)) q (2838 . 2)) ((c form c (c (? . 0) q for*/lists)) q (10937 . 4)) ((c form c (c (? . 4) q FTP-Connection)) q (15005 . 2)) ((c form c (c (? . 1) q UnitTop)) q (22118 . 2)) ((c form c (c (? . 1) q Flonum-Positive-Zero)) q (834 . 2)) ((c form c (c (? . 1) q Immutable-Vectorof)) q (3450 . 2)) ((c form c (c (? . 1) q Nonnegative-Float)) q (605 . 2)) ((c form c (c (? . 1) q Option)) q (7060 . 2)) ((c form c (c (? . 1) q Float)) q (87 . 2)) ((c form c (c (? . 0) q typecheck-fail)) q (23062 . 8)) ((c form c (c (? . 4) q #%top-interaction)) q (14900 . 2)) ((c form c (c (? . 3) q case->)) q (6615 . 2)) ((c form c (c (? . 0) q for*/or:)) q (25999 . 2)) ((c form c (c (? . 0) q for*/hasheqv)) q (9858 . 2)) ((c form c (c (? . 0) q for*/vector:)) q (26053 . 2)) ((c form c (c (? . 1) q Mutable-Vectorof)) q (3481 . 2)) ((c form c (c (? . 1) q Logger)) q (2932 . 2)) ((c form c (c (? . 1) q Exact-Positive-Integer)) q (392 . 2)) ((c form c (c (? . 3) q Instance)) q (19130 . 2)) ((c form c (c (? . 1) q Sexp)) q (4382 . 2)) ((c form c (c (? . 3) q AnyValues)) q (11 . 2)) ((c form c (c (? . 1) q Weak-Boxof)) q (4210 . 2)) ((c form c (c (? . 0) q do:)) q (26376 . 2)) ((c form c (c (? . 1) q Nonpositive-ExtFlonum)) q (1946 . 2)) ((c form c (c (? . 3) q Refine)) q (27268 . 32)) ((c form c (c (? . 2) q init-rest)) q (18093 . 2)) ((c form c (c (? . 0) q for*/hasheq)) q (9790 . 2)) ((c form c (c (? . 0) q for/hash:)) q (26182 . 2)) ((c form c (c (? . 1) q ExtFlonum-Zero)) q (2037 . 2)) ((c form c (c (? . 0) q :)) q (13662 . 3)) ((c form c (c (? . 0) q let*-values:)) q (25314 . 2)) ((c form c (c (? . 0) q ann)) q (13741 . 2)) ((c form c (c (? . 1) q Module-Path-Index)) q (2512 . 2)) ((c form c (c (? . 1) q Positive-Index)) q (1714 . 2)) ((c form c (c (? . 1) q HashTableTop)) q (3816 . 2)) ((c form c (c (? . 4) q SSL-Client-Context)) q (15181 . 2)) ((c form c (c (? . 1) q Number)) q (43 . 2)) ((c def c (c (? . 8) q defined?)) q (22956 . 3)) ((c form c (c (? . 1) q Pairof)) q (3204 . 2)) ((c form c (c (? . 1) q Flonum)) q (100 . 2)) ((c form c (c (? . 1) q Single-Flonum-Zero)) q (1130 . 2)) ((c form c (c (? . 1) q Exact-Number)) q (189 . 2)) ((c form c (c (? . 1) q Single-Flonum-Complex)) q (230 . 2)) ((c form c (c (? . 0) q for*/last:)) q (25927 . 2)) ((c form c (c (? . 7) q define-type)) q (13439 . 6)) ((c form c (c (? . 0) q pcase-lambda:)) q (24846 . 3)) ((c form c (c (? . 3) q Values)) q (6721 . 2)) ((c form c (c (? . 0) q for/hasheqv)) q (9195 . 2)) ((c form c (c (? . 3) q List)) q (3245 . 2)) ((c form c (c (? . 3) q âˆ€)) q (7049 . 2)) ((c form c (c (? . 1) q Security-Guard)) q (2872 . 2)) ((c form c (c (? . 1) q MListof)) q (3338 . 2)) ((c form c (c (? . 3) q Un)) q (26563 . 2)) ((c form c (c (? . 1) q Log-Level)) q (2966 . 2)) ((c form c (c (? . 1) q Parameterization)) q (2814 . 2)) ((c form c (c (? . 0) q define-new-subtype)) q (27216 . 2)) ((c form c (c (? . 1) q Weak-BoxTop)) q (4233 . 2)) ((c form c (c (? . 2) q init)) q (17955 . 2)) ((c form c (c (? . 1) q Null)) q (2424 . 2)) ((c form c (c (? . 6) q compound-unit/infer)) q (20548 . 15)) ((c form c (c (? . 1) q Positive-Flonum)) q (582 . 2)) ((c form c (c (? . 0) q for*/product:)) q (26015 . 2)) ((c form c (c (? . 3) q Imp)) q (6979 . 2)) ((c form c (c (? . 3) q Top)) q (6536 . 2)) ((c form c (c (? . 1) q Natural)) q (482 . 2)) ((c form c (c (? . 1) q Boxof)) q (3397 . 2)) ((c form c (c (? . 0) q do)) q (11222 . 7)) ((c form c (c (? . 1) q Nonpositive-Flonum)) q (726 . 2)) ((c form c (c (? . 1) q Regexp)) q (2276 . 2)) ((c form c (c (? . 0) q require/opaque-type)) q (26439 . 2)) ((c form c (c (? . 2) q augment)) q (18247 . 2)) ((c form c (c (? . 1) q HashTable)) q (3693 . 2)) ((c form c (c (? . 0) q for/last)) q (9529 . 2)) ((c form c (c (? . 2) q class)) q (15593 . 45)) ((c form c (c (? . 4) q URL-Exception)) q (15092 . 2)) ((c form c (c (? . 0) q for*/sum:)) q (26036 . 2)) ((c form c (c (? . 0) q Î»)) q (8545 . 2)) ((c form c (c (? . 4) q JSExpr)) q (14969 . 2)) ((c form c (c (? . 0) q for/set)) q (9594 . 2)) ((c form c (c (? . 4) q for/flvector)) q (15408 . 2)) ((c form c (c (? . 1) q Nonnegative-Flonum)) q (630 . 2)) ((c form c (c (? . 0) q :print-type)) q (23671 . 2)) ((c form c (c (? . 3) q Object)) q (19005 . 5)) ((c form c (c (? . 1) q False)) q (2107 . 2)) ((c form c (c (? . 1) q Mutable-HashTableTop)) q (3836 . 2)) ((c form c (c (? . 1) q Vectorof)) q (3429 . 2)) ((c form c (c (? . 0) q let*)) q (7475 . 2)) ((c form c (c (? . 3) q Intersection)) q (7003 . 2)) ((c form c (c (? . 0) q define-struct)) q (12834 . 12)) ((c form c (c (? . 1) q Single-Flonum)) q (114 . 2)) ((c form c (c (? . 0) q for*/vector)) q (9927 . 2)) ((c def c (c (? . 8) q assert)) q (22737 . 6)) ((c form c (c (? . 1) q Pseudo-Random-Generator)) q (3125 . 2)) ((c form c (c (? . 1) q Will-Executor)) q (3104 . 2)) ((c form c (c (? . 0) q for*/last)) q (10197 . 2)) ((c form c (c (? . 1) q Nonnegative-Integer)) q (422 . 2)) ((c form c (c (? . 3) q Prefab)) q (6869 . 2)) ((c form c (c (? . 1) q String)) q (2120 . 2)) ((c form c (c (? . 1) q Float-Nan)) q (899 . 2)) ((c form c (c (? . 1) q ExtFlonum)) q (1848 . 2)) ((c form c (c (? . 1) q Nonpositive-Integer)) q (521 . 2)) ((c form c (c (? . 1) q TCP-Listener)) q (2912 . 2)) ((c form c (c (? . 1) q Namespace-Anchor)) q (2374 . 2)) ((c form c (c (? . 1) q Async-Channelof)) q (3947 . 2)) ((c form c (c (? . 1) q Nonnegative-Fixnum)) q (1773 . 2)) ((c form c (c (? . 1) q Port)) q (2224 . 2)) ((c form c (c (? . 0) q for/list)) q (8998 . 2)) ((c form c (c (? . 1) q Single-Flonum-Negative-Zero)) q (1060 . 2)) ((c form c (c (? . 1) q ExtFlonum-Negative-Zero)) q (1975 . 2)) ((c form c (c (? . 3) q âˆ©)) q (6594 . 2)) ((c form c (c (? . 1) q Evtof)) q (4276 . 2)) ((c form c (c (? . 2) q init-field)) q (17985 . 2)) ((c form c (c (? . 1) q Integer)) q (72 . 2)) ((c form c (c (? . 1) q Nonpositive-Real)) q (1616 . 2)) ((c form c (c (? . 0) q define)) q (11404 . 30)) ((c form c (c (? . 4) q PortT/Bytes)) q (15122 . 2)) ((c form c (c (? . 0) q let-values)) q (7513 . 2)) ((c form c (c (? . 0) q for/first)) q (10392 . 2)) ((c form c (c (? . 0) q for/hasheq)) q (9128 . 2)) ((c form c (c (? . 2) q define/augment)) q (17795 . 3)) ((c form c (c (? . 9) q define-typed/untyped-identifier)) q (23460 . 2)) ((c form c (c (? . 1) q Environment-Variables)) q (3156 . 2)) ((c form c (c (? . 3) q Opaque)) q (7079 . 2)) ((c form c (c (? . 4) q Char-Set)) q (15547 . 2)) ((c form c (c (? . 0) q let-values:)) q (25193 . 2)) ((c form c (c (? . 1) q Resolved-Module-Path)) q (2537 . 2)) ((c form c (c (? . 0) q let/cc)) q (7688 . 2)) ((c form c (c (? . 1) q Keyword)) q (2134 . 2)) ((c form c (c (? . 2) q define/private)) q (17875 . 3)) ((c form c (c (? . 4) q SSL-Listener)) q (15222 . 2)) ((c form c (c (? . 1) q Negative-Single-Flonum)) q (997 . 2)) ((c form c (c (? . 0) q for*/set:)) q (25982 . 2)) ((c form c (c (? . 1) q Inexact-Real-Positive-Zero)) q (1337 . 2)) ((c form c (c (? . 0) q make-predicate)) q (13600 . 2)) ((c form c (c (? . 1) q One)) q (1657 . 2)) ((c form c (c (? . 1) q Zero)) q (548 . 2)) ((c form c (c (? . 1) q Weak-HashTable)) q (3786 . 2)) ((c form c (c (? . 1) q Setof)) q (3889 . 2)) ((c form c (c (? . 1) q Void)) q (2175 . 2)) ((c form c (c (? . 2) q define/override)) q (17633 . 3)) ((c form c (c (? . 0) q for*/sum)) q (10063 . 2)) ((c form c (c (? . 0) q for/and)) q (10328 . 2)) ((c form c (c (? . 1) q MPairTop)) q (3381 . 2)) ((c form c (c (? . 10) q unsafe-require/typed/provide)) q (24152 . 2)) ((c form c (c (? . 1) q Nonpositive-Inexact-Real)) q (1271 . 2)) ((c form c (c (? . 1) q Continuation-Mark-KeyTop)) q (4492 . 2)) ((c form c (c (? . 0) q let:)) q (24957 . 3)) ((c form c (c (? . 1) q Pretty-Print-Style-Table)) q (2661 . 2)) ((c form c (c (? . 0) q define-struct/exec)) q (13193 . 8)) ((c form c (c (? . 1) q Internal-Definition-Context)) q (2626 . 2)) ((c form c (c (? . 0) q opt-lambda:)) q (24489 . 6)) ((c form c (c (? . 1) q Compiled-Module-Expression)) q (2565 . 2)) ((c form c (c (? . 1) q ChannelTop)) q (3929 . 2)) ((c form c (c (? . 1) q Positive-ExtFlonum)) q (1865 . 2)) ((c form c (c (? . 0) q for/vector:)) q (26357 . 2)) ((c form c (c (? . 0) q for*)) q (10873 . 3)) ((c form c (c (? . 3) q PrefabTop)) q (6901 . 2)) ((c form c (c (? . 1) q Negative-Fixnum)) q (1799 . 2)) ((c form c (c (? . 1) q Nonnegative-Inexact-Real)) q (1210 . 2)) ((c form c (c (? . 3) q pred)) q (26546 . 2)) ((c form c (c (? . 0) q struct:)) q (25691 . 2)) ((c form c (c (? . 0) q require-typed-struct)) q (26466 . 2)) ((c form c (c (? . 1) q Negative-Exact-Rational)) q (1485 . 2)) ((c form c (c (? . 0) q for*/or)) q (9995 . 2)) ((c form c (c (? . 1) q Undefined)) q (2476 . 2)) ((c form c (c (? . 1) q Place-Channel)) q (3048 . 2)) ((c form c (c (? . 1) q Inexact-Real)) q (135 . 2)) ((c form c (c (? . 3) q Sequenceof)) q (4084 . 2)) ((c form c (c (? . 1) q Real)) q (177 . 2)) ((c form c (c (? . 0) q for/or:)) q (26306 . 2)) ((c form c (c (? . 3) q â†’)) q (7023 . 2)) ((c form c (c (? . 1) q Negative-Integer)) q (497 . 2)) ((c form c (c (? . 0) q let*:)) q (25149 . 2)) ((c form c (c (? . 1) q Inexact-Real-Zero)) q (1371 . 2)) ((c form c (c (? . 6) q define-unit-from-context)) q (21685 . 2)) ((c form c (c (? . 0) q for*/and)) q (10458 . 2)) ((c form c (c (? . 4) q Cursor)) q (15561 . 2)) ((c form c (c (? . 1) q Nonnegative-Exact-Rational)) q (1451 . 2)) ((c form c (c (? . 0) q require/typed/provide)) q (14702 . 2)) ((c form c (c (? . 1) q Positive-Exact-Rational)) q (1420 . 2)) ((c form c (c (? . 4) q GIF-Colormap)) q (14951 . 2)) ((c form c (c (? . 0) q with-handlers)) q (14752 . 2)) ((c form c (c (? . 4) q SSL-Context)) q (15205 . 2)) ((c form c (c (? . 1) q Variable-Reference)) q (2398 . 2)) ((c form c (c (? . 2) q pubment)) q (18162 . 2)) ((c form c (c (? . 0) q define-typed-struct)) q (26412 . 2)) ((c form c (c (? . 0) q letrec)) q (7435 . 2)) ((c form c (c (? . 3) q ->)) q (4524 . 52)) ((c form c (c (? . 1) q Namespace)) q (2357 . 2)) ((c form c (c (? . 1) q Listof)) q (3226 . 2)) ((c form c (c (? . 0) q for*:)) q (26073 . 2)) ((c form c (c (? . 3) q Vector)) q (3510 . 2)) ((c form c (c (? . 0) q pdefine:)) q (26530 . 2)) ((c form c (c (? . 0) q with-asserts)) q (22852 . 5)) ((c form c (c (? . 6) q define-compound-unit/infer)) q (21173 . 5)) ((c form c (c (? . 0) q for/vector)) q (9263 . 2)) ((c form c (c (? . 3) q Unit)) q (21733 . 13)) ((c form c (c (? . 3) q ->*)) q (6138 . 15)) ((c form c (c (? . 1) q Module-Path)) q (2493 . 2)) ((c form c (c (? . 0) q case-lambda)) q (8574 . 2)) ((c form c (c (? . 0) q for*/lists:)) q (25963 . 2)) ((c form c (c (? . 0) q :query-type/args)) q (23695 . 2)) ((c form c (c (? . 0) q for/and:)) q (26086 . 2)) ((c form c (c (? . 0) q :query-type/result)) q (23732 . 2)) ((c form c (c (? . 3) q Refinement)) q (27146 . 2)) ((c form c (c (? . 1) q Subprocess)) q (3017 . 2)) ((c form c (c (? . 1) q Positive-Byte)) q (1680 . 2)) ((c form c (c (? . 1) q UDP-Socket)) q (2894 . 2)) ((c form c (c (? . 0) q struct)) q (12334 . 15)) ((c form c (c (? . 1) q Negative-Float)) q (656 . 2)) ((c form c (c (? . 0) q for/fold:)) q (26165 . 2)) ((c form c (c (? . 3) q caseâ†’)) q (7034 . 2)) ((c form c (c (? . 1) q Mutable-VectorTop)) q (3668 . 2)) ((c form c (c (? . 0) q for*/hash:)) q (25868 . 2)) ((c form c (c (? . 1) q Positive-Real)) q (1550 . 2)) ((c form c (c (? . 1) q Char)) q (2163 . 2)) ((c form c (c (? . 0) q for:)) q (25755 . 2)) ((c form c (c (? . 2) q inherit)) q (18320 . 2)) ((c form c (c (? . 9) q require/untyped-contract)) q (23327 . 5)) ((c form c (c (? . 1) q Any)) q (0 . 2)) ((c form c (c (? . 0) q require-typed-struct/provide)) q (26494 . 2)) ((c def c (c (? . 9) q syntax-local-typed-context?)) q (23533 . 2)) ((c form c (c (? . 1) q Nonpositive-Float)) q (701 . 2)) ((c form c (c (? . 4) q SSL-Server-Context)) q (15157 . 2)) ((c form c (c (? . 0) q letrec:)) q (25103 . 2)) ((c form c (c (? . 0) q for*/product)) q (10128 . 2)) ((c form c (c (? . 0) q for*/hasheq:)) q (25886 . 2)) ((c form c (c (? . 6) q define-unit)) q (20405 . 7)) ((c form c (c (? . 1) q Single-Flonum-Nan)) q (1156 . 2)) ((c form c (c (? . 3) q Bot)) q (6547 . 2)) ((c form c (c (? . 0) q for/hasheq:)) q (26199 . 2)) ((c form c (c (? . 0) q for)) q (8630 . 14)) ((c form c (c (? . 1) q Positive-Single-Flonum)) q (934 . 2)) ((c form c (c (? . 1) q Thread-Cellof)) q (4162 . 2)) ((c form c (c (? . 0) q for/flvector:)) q (26120 . 2)) ((c form c (c (? . 1) q Boolean)) q (2080 . 2)) ((c form c (c (? . 1) q Async-ChannelTop)) q (3975 . 2)) ((c form c (c (? . 1) q ExtFlonum-Nan)) q (2059 . 2)) ((c form c (c (? . 4) q IMAP-Connection)) q (15046 . 2)) ((c form c (c (? . 1) q Weak-HashTableTop)) q (3864 . 2)) ((c form c (c (? . 0) q let*-values)) q (7630 . 2)) ((c form c (c (? . 3) q All)) q (6668 . 3)) ((c form c (c (? . 1) q Nothing)) q (28 . 2)) ((c form c (c (? . 3) q Struct)) q (6802 . 2)) ((c form c (c (? . 6) q invoke-unit/infer)) q (21318 . 5)) ((c form c (c (? . 0) q cast)) q (13779 . 2)) ((c form c (c (? . 0) q for/hasheqv:)) q (26218 . 2)) ((c form c (c (? . 1) q FxVector)) q (3635 . 2)) ((c form c (c (? . 1) q Log-Receiver)) q (2946 . 2)) ((c form c (c (? . 1) q Semaphore)) q (3069 . 2)) ((c form c (c (? . 1) q Input-Port)) q (2187 . 2)) ((c form c (c (? . 1) q Inexact-Imaginary)) q (343 . 2)) ((c def c (c (? . 0) q index?)) q (23010 . 3)) ((c form c (c (? . 10) q unsafe-require/typed)) q (24060 . 2)) ((c form c (c (? . 0) q Î»:)) q (24368 . 2)) ((c form c (c (? . 0) q for/sum:)) q (26341 . 2)) ((c form c (c (? . 0) q row-inst)) q (13857 . 2)) ((c form c (c (? . 0) q define-predicate)) q (13627 . 2)) ((c form c (c (? . 6) q define-signature)) q (19202 . 8)) ((c form c (c (? . 4) q Date)) q (15583 . 2)) ((c form c (c (? . 0) q for*/fold)) q (11043 . 7)) ((c form c (c (? . 1) q Procedure)) q (6558 . 2)) ((c form c (c (? . 0) q :type)) q (23587 . 5)) ((c form c (c (? . 1) q Special-Comment)) q (2693 . 2)) ((c form c (c (? . 1) q Mutable-HashTable)) q (3753 . 2)) ((c form c (c (? . 6) q compound-unit)) q (20166 . 9)) ((c form c (c (? . 0) q for/list:)) q (26255 . 2)) ((c form c (c (? . 1) q Exact-Complex)) q (299 . 2)) ((c form c (c (? . 0) q for/first:)) q (26102 . 2)) ((c form c (c (? . 4) q SSL-Protocol)) q (15139 . 2)) ((c form c (c (? . 1) q Fixnum)) q (1736 . 2)) ((c form c (c (? . 1) q Prompt-Tagof)) q (4407 . 2)) ((c form c (c (? . 0) q require/typed)) q (13944 . 20)) ((c form c (c (? . 0) q letrec-values:)) q (25252 . 2)) ((c form c (c (? . 0) q let/ec)) q (7721 . 2)) ((c form c (c (? . 0) q for/set:)) q (26290 . 2)) ((c form c (c (? . 3) q Rec)) q (6783 . 2)) ((c form c (c (? . 0) q letrec-values)) q (7570 . 2)) ((c form c (c (? . 4) q HTTP-Connection)) q (15025 . 2)) ((c form c (c (? . 1) q Struct-TypeTop)) q (6847 . 2)) ((c form c (c (? . 0) q define-struct:)) q (25706 . 2)) ((c form c (c (? . 1) q Futureof)) q (4063 . 2)) ((c form c (c (? . 3) q mu)) q (26573 . 2)) ((c form c (c (? . 1) q Compiled-Expression)) q (2599 . 2)) ((c form c (c (? . 1) q SequenceTop)) q (4115 . 2)) ((c form c (c (? . 4) q PortT)) q (15111 . 2)) ((c form c (c (? . 0) q assert-typecheck-fail)) q (23227 . 3)) ((c form c (c (? . 2) q inherit-field)) q (18053 . 2)) ((c form c (c (? . 2) q field)) q (18021 . 2)) ((c form c (c (? . 3) q Immutable-Vector)) q (3534 . 2)) ((c form c (c (? . 2) q define/public)) q (17555 . 3)) ((c form c (c (? . 0) q for*/set)) q (10263 . 2)) ((c form c (c (? . 4) q GIF-Stream)) q (14935 . 2)) ((c form c (c (? . 0) q let/ec:)) q (25408 . 2)) ((c form c (c (? . 0) q for*/fold:)) q (25850 . 2)) ((c form c (c (? . 0) q define-typed-struct/exec)) q (27170 . 2)) ((c form c (c (? . 1) q MPairof)) q (3358 . 2)) ((c form c (c (? . 1) q Syntaxof)) q (4294 . 2)) ((c form c (c (? . 0) q for*/first:)) q (25784 . 2)) ((c form c (c (? . 1) q Read-Table)) q (2773 . 2)) ((c form c (c (? . 6) q define-values/invoke-unit/infer)) q (21422 . 8)) ((c form c (c (? . 3) q U)) q (6575 . 2)) ((c form c (c (? . 1) q Nonpositive-Single-Flonum)) q (1027 . 2)) ((c form c (c (? . 1) q VectorTop)) q (3651 . 2)) ((c form c (c (? . 4) q for*/extflvector)) q (15335 . 2)) ((c form c (c (? . 1) q Imaginary)) q (282 . 2)) ((c form c (c (? . 1) q Index)) q (1701 . 2)) ((c form c (c (? . 1) q FlVector)) q (3600 . 2)) ((c form c (c (? . 3) q Struct-Type)) q (6822 . 2)) ((c form c (c (? . 1) q ClassTop)) q (18989 . 2)) ((c form c (c (? . 1) q Output-Port)) q (2205 . 2)) ((c form c (c (? . 10) q unsafe-provide)) q (24109 . 2)) ((c form c (c (? . 4) q Path/Param)) q (15067 . 2)) ((c form c (c (? . 1) q Sexpof)) q (4363 . 2)) ((c form c (c (? . 1) q Path-For-Some-System)) q (2248 . 2)) ((c form c (c (? . 0) q for*/extflvector:)) q (25825 . 2)) ((c form c (c (? . 1) q Positive-Fixnum)) q (1750 . 2)) ((c form c (c (? . 0) q for*/list)) q (9658 . 2)) ((c form c (c (? . 6) q unit)) q (19384 . 16)) ((c form c (c (? . 1) q Nonnegative-Single-Flonum)) q (964 . 2)) ((c form c (c (? . 1) q Inspector)) q (2855 . 2)) ((c form c (c (? . 1) q Pair)) q (26613 . 2)) ((c form c (c (? . 1) q Thread)) q (2983 . 2)) ((c form c (c (? . 0) q for/hash)) q (9063 . 2)) ((c form c (c (? . 0) q let/cc:)) q (25374 . 2)) ((c form c (c (? . 0) q for*/and:)) q (25767 . 2)) ((c form c (c (? . 0) q for/sum)) q (9397 . 2)) ((c form c (c (? . 4) q for*/flvector)) q (15477 . 2)) ((c form c (c (? . 1) q Float-Complex)) q (209 . 2)) ((c form c (c (? . 1) q Thread-CellTop)) q (4188 . 2)) ((c form c (c (? . 3) q Union)) q (6990 . 2)) ((c form c (c (? . 1) q Positive-Integer)) q (368 . 2)) ((c form c (c (? . 6) q define-values/invoke-unit)) q (19928 . 8)) ((c form c (c (? . 1) q Exact-Rational)) q (155 . 2)) ((c form c (c (? . 4) q Time)) q (15573 . 2)) ((c form c (c (? . 3) q !)) q (28384 . 2))))
syntax
Any
syntax
AnyValues
syntax
Nothing
syntax
Number
syntax
Complex
syntax
Integer
syntax
Float
syntax
Flonum
syntax
Single-Flonum
syntax
Inexact-Real
syntax
Exact-Rational
syntax
Real
syntax
Exact-Number
syntax
Float-Complex
syntax
Single-Flonum-Complex
syntax
Inexact-Complex
syntax
Imaginary
syntax
Exact-Complex
syntax
Exact-Imaginary
syntax
Inexact-Imaginary
syntax
Positive-Integer
syntax
Exact-Positive-Integer
syntax
Nonnegative-Integer
syntax
Exact-Nonnegative-Integer
syntax
Natural
syntax
Negative-Integer
syntax
Nonpositive-Integer
syntax
Zero
syntax
Positive-Float
syntax
Positive-Flonum
syntax
Nonnegative-Float
syntax
Nonnegative-Flonum
syntax
Negative-Float
syntax
Negative-Flonum
syntax
Nonpositive-Float
syntax
Nonpositive-Flonum
syntax
Float-Negative-Zero
syntax
Flonum-Negative-Zero
syntax
Float-Positive-Zero
syntax
Flonum-Positive-Zero
syntax
Float-Zero
syntax
Flonum-Zero
syntax
Float-Nan
syntax
Flonum-Nan
syntax
Positive-Single-Flonum
syntax
Nonnegative-Single-Flonum
syntax
Negative-Single-Flonum
syntax
Nonpositive-Single-Flonum
syntax
Single-Flonum-Negative-Zero
syntax
Single-Flonum-Positive-Zero
syntax
Single-Flonum-Zero
syntax
Single-Flonum-Nan
syntax
Positive-Inexact-Real
syntax
Nonnegative-Inexact-Real
syntax
Negative-Inexact-Real
syntax
Nonpositive-Inexact-Real
syntax
Inexact-Real-Negative-Zero
syntax
Inexact-Real-Positive-Zero
syntax
Inexact-Real-Zero
syntax
Inexact-Real-Nan
syntax
Positive-Exact-Rational
syntax
Nonnegative-Exact-Rational
syntax
Negative-Exact-Rational
syntax
Nonpositive-Exact-Rational
syntax
Positive-Real
syntax
Nonnegative-Real
syntax
Negative-Real
syntax
Nonpositive-Real
syntax
Real-Zero
syntax
One
syntax
Byte
syntax
Positive-Byte
syntax
Index
syntax
Positive-Index
syntax
Fixnum
syntax
Positive-Fixnum
syntax
Nonnegative-Fixnum
syntax
Negative-Fixnum
syntax
Nonpositive-Fixnum
syntax
ExtFlonum
syntax
Positive-ExtFlonum
syntax
Nonnegative-ExtFlonum
syntax
Negative-ExtFlonum
syntax
Nonpositive-ExtFlonum
syntax
ExtFlonum-Negative-Zero
syntax
ExtFlonum-Positive-Zero
syntax
ExtFlonum-Zero
syntax
ExtFlonum-Nan
syntax
Boolean
syntax
True
syntax
False
syntax
String
syntax
Keyword
syntax
Symbol
syntax
Char
syntax
Void
syntax
Input-Port
syntax
Output-Port
syntax
Port
syntax
Path
syntax
Path-For-Some-System
syntax
Regexp
syntax
PRegexp
syntax
Byte-Regexp
syntax
Byte-PRegexp
syntax
Bytes
syntax
Namespace
syntax
Namespace-Anchor
syntax
Variable-Reference
syntax
Null
syntax
EOF
syntax
Continuation-Mark-Set
syntax
Undefined
syntax
Module-Path
syntax
Module-Path-Index
syntax
Resolved-Module-Path
syntax
Compiled-Module-Expression
syntax
Compiled-Expression
syntax
Internal-Definition-Context
syntax
Pretty-Print-Style-Table
syntax
Special-Comment
syntax
Struct-Type-Property
syntax
Impersonator-Property
syntax
Read-Table
syntax
Bytes-Converter
syntax
Parameterization
syntax
Custodian
syntax
Inspector
syntax
Security-Guard
syntax
UDP-Socket
syntax
TCP-Listener
syntax
Logger
syntax
Log-Receiver
syntax
Log-Level
syntax
Thread
syntax
Thread-Group
syntax
Subprocess
syntax
Place
syntax
Place-Channel
syntax
Semaphore
syntax
FSemaphore
syntax
Will-Executor
syntax
Pseudo-Random-Generator
syntax
Environment-Variables
syntax
Path-String
syntax
(PairofÂ sÂ t)
syntax
(ListofÂ t)
syntax
(ListÂ tÂ ...)
syntax
(ListÂ tÂ ...Â trestÂ ...Â bound)
syntax
(List*Â tÂ t1Â ...Â s)
syntax
(MListofÂ t)
syntax
(MPairofÂ tÂ u)
syntax
MPairTop
syntax
(BoxofÂ t)
syntax
BoxTop
syntax
(VectorofÂ t)
syntax
(Immutable-VectorofÂ t)
syntax
(Mutable-VectorofÂ t)
syntax
(VectorÂ tÂ ...)
syntax
(Immutable-VectorÂ tÂ ...)
syntax
(Mutable-VectorÂ tÂ ...)
syntax
FlVector
syntax
ExtFlVector
syntax
FxVector
syntax
VectorTop
syntax
Mutable-VectorTop
syntax
(HashTableÂ kÂ v)
syntax
(Immutable-HashTableÂ kÂ v)
syntax
(Mutable-HashTableÂ kÂ v)
syntax
(Weak-HashTableÂ kÂ v)
syntax
HashTableTop
syntax
Mutable-HashTableTop
syntax
Weak-HashTableTop
syntax
(SetofÂ t)
syntax
(ChannelofÂ t)
syntax
ChannelTop
syntax
(Async-ChannelofÂ t)
syntax
Async-ChannelTop
syntax
(ParameterofÂ t)
(ParameterofÂ sÂ t)
syntax
(PromiseÂ t)
syntax
(FutureofÂ t)
syntax
(SequenceofÂ tÂ tÂ ...)
syntax
SequenceTop
syntax
(Custodian-BoxofÂ t)
syntax
(Thread-CellofÂ t)
syntax
Thread-CellTop
syntax
(Weak-BoxofÂ t)
syntax
Weak-BoxTop
syntax
(EphemeronofÂ t)
syntax
(EvtofÂ t)
syntax
(SyntaxofÂ t)
syntax
Identifier
syntax
Syntax
syntax
Syntax-E
syntax
(SexpofÂ t)
syntax
Sexp
syntax
Datum
syntax
(Prompt-TagofÂ sÂ t)
syntax
Prompt-TagTop
syntax
(Continuation-Mark-KeyofÂ t)
syntax
Continuation-Mark-KeyTop
syntax
(->Â domÂ ...Â rngÂ opt-proposition)
(->Â domÂ ...Â restÂ *Â rng)
(->Â domÂ ...Â restÂ oooÂ boundÂ rng)
(domÂ ...Â ->Â rngÂ opt-proposition)
(domÂ ...Â restÂ *Â ->Â rng)
(domÂ ...Â restÂ oooÂ boundÂ ->Â rng)
Â 
            oooÂ =Â ...
              Â Â Â Â Â 
            domÂ =Â type
              Â Â |Â mandatory-kw
              Â Â |Â opt-kw
              Â Â Â Â Â 
            rngÂ =Â type
              Â Â |Â (ValuesÂ typeÂ ...)
              Â Â Â Â Â 
   mandatory-kwÂ =Â keywordÂ type
              Â Â Â Â Â 
         opt-kwÂ =Â [keywordÂ type]
              Â Â Â Â Â 
opt-propositionÂ =Â 
              Â Â |Â :Â type
              Â Â |Â :Â pos-proposition
                  Â Â neg-proposition
                  Â Â object
              Â Â Â Â Â 
pos-propositionÂ =Â 
              Â Â |Â #:+Â propositionÂ ...
              Â Â Â Â Â 
neg-propositionÂ =Â 
              Â Â |Â #:-Â propositionÂ ...
              Â Â Â Â Â 
         objectÂ =Â 
              Â Â |Â #:objectÂ index
              Â Â Â Â Â 
    propositionÂ =Â Top
              Â Â |Â Bot
              Â Â |Â type
              Â Â |Â (!Â type)
              Â Â |Â (typeÂ @Â path-elemÂ ...Â index)
              Â Â |Â (!Â typeÂ @Â path-elemÂ ...Â index)
              Â Â |Â (andÂ propositionÂ ...)
              Â Â |Â (orÂ propositionÂ ...)
              Â Â |Â (impliesÂ propositionÂ ...)
              Â Â Â Â Â 
      path-elemÂ =Â car
              Â Â |Â cdr
              Â Â Â Â Â 
          indexÂ =Â positive-integer
              Â Â |Â (positive-integerÂ positive-integer)
              Â Â |Â identifier
syntax
(->*Â (mandatory-domÂ ...)Â optional-domsÂ restÂ rng)
Â 
mandatory-domÂ =Â type
            Â Â |Â keywordÂ type
            Â Â Â Â Â 
optional-domsÂ =Â 
            Â Â |Â (optional-domÂ ...)
            Â Â Â Â Â 
 optional-domÂ =Â type
            Â Â |Â keywordÂ type
            Â Â Â Â Â 
         restÂ =Â 
            Â Â |Â #:restÂ type
            Â Â |Â #:rest-starÂ (typeÂ ...)
syntax
Top
syntax
Bot
syntax
Procedure
syntax
(UÂ tÂ ...)
syntax
(âˆ©Â tÂ ...)
syntax
(case->Â fun-tyÂ ...)
syntax
(tÂ t1Â t2Â ...)
syntax
(AllÂ (aÂ ...)Â t)
(AllÂ (aÂ ...Â aÂ ooo)Â t)
syntax
(ValuesÂ tÂ ...)
syntax
v
syntax
(quoteÂ val)
syntax
i
syntax
(RecÂ nÂ t)
syntax
(StructÂ st)
syntax
(Struct-TypeÂ st)
syntax
Struct-TypeTop
syntax
(PrefabÂ keyÂ typeÂ ...)
syntax
(PrefabTopÂ keyÂ field-count)
syntax
(Struct-PropertyÂ ty)
syntax
Self
syntax
Imp
syntax
Union
syntax
Intersection
syntax
â†’
syntax
caseâ†’
syntax
âˆ€
syntax
(OptionÂ t)
syntax
(OpaqueÂ t)
syntax
(letÂ maybe-tvarsÂ (bindingÂ ...)Â . body)
(letÂ loopÂ maybe-retÂ (bindingÂ ...)Â . body)
Â 
    bindingÂ =Â [varÂ e]
          Â Â |Â [varÂ :Â typeÂ e]
          Â Â Â Â Â 
maybe-tvarsÂ =Â 
          Â Â |Â #:forallÂ (tvarÂ ...)
          Â Â |Â #:âˆ€Â (tvarÂ ...)
          Â Â Â Â Â 
  maybe-retÂ =Â 
          Â Â |Â :Â type0
syntax
(letrecÂ (bindingÂ ...)Â . body)
syntax
(let*Â (bindingÂ ...)Â . body)
syntax
(let-valuesÂ ([(var+typeÂ ...)Â e]Â ...)Â . body)
syntax
(letrec-valuesÂ ([(var+typeÂ ...)Â e]Â ...)Â . body)
syntax
(let*-valuesÂ ([(var+typeÂ ...)Â e]Â ...)Â . body)
syntax
(let/ccÂ vÂ :Â tÂ . body)
syntax
(let/ecÂ vÂ :Â tÂ . body)
syntax
(lambdaÂ maybe-tvarsÂ formalsÂ maybe-retÂ . body)
Â 
    formalsÂ =Â (formalÂ ...)
          Â Â |Â (formalÂ ...Â . rst)
          Â Â Â Â Â 
     formalÂ =Â var
          Â Â |Â [varÂ default-expr]
          Â Â |Â [varÂ :Â type]
          Â Â |Â [varÂ :Â typeÂ default-expr]
          Â Â |Â keywordÂ var
          Â Â |Â keywordÂ [varÂ :Â type]
          Â Â |Â keywordÂ [varÂ :Â typeÂ default-expr]
          Â Â Â Â Â 
        rstÂ =Â var
          Â Â |Â [varÂ :Â typeÂ *]
          Â Â |Â [varÂ :Â typeÂ oooÂ bound]
          Â Â Â Â Â 
maybe-tvarsÂ =Â 
          Â Â |Â #:forallÂ (tvarÂ ...)
          Â Â |Â #:âˆ€Â (tvarÂ ...)
          Â Â |Â #:forallÂ (tvarÂ ...Â ooo)
          Â Â |Â #:âˆ€Â (tvarÂ ...Â ooo)
          Â Â Â Â Â 
  maybe-retÂ =Â 
          Â Â |Â :Â type
syntax
(Î»Â formalsÂ . body)
syntax
(case-lambdaÂ maybe-tvarsÂ [formalsÂ body]Â ...)
syntax
(forÂ type-ann-maybeÂ (for-clauseÂ ...)
Â Â exprÂ ...+)
Â 
type-ann-maybeÂ =Â 
             Â Â |Â :Â u
             Â Â Â Â Â 
    for-clauseÂ =Â [idÂ :Â tÂ seq-expr]
             Â Â |Â [(bindingÂ ...)Â seq-expr]
             Â Â |Â [idÂ seq-expr]
             Â Â |Â #:whenÂ guard
             Â Â Â Â Â 
       bindingÂ =Â id
             Â Â |Â [idÂ :Â t]
syntax
(for/listÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/hashÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/hasheqÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/hasheqvÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/vectorÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/orÂ Â Â type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/sumÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/productÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/lastÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/setÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/listÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/hashÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/hasheqÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/hasheqvÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/vectorÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/orÂ Â Â type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/sumÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/productÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/lastÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/setÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/andÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/firstÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/andÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/firstÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/listsÂ type-ann-maybeÂ ([idÂ :Â t]Â ...Â maybe-result)
Â Â (for-clauseÂ ...)
Â Â exprÂ ...+)
syntax
(for/foldÂ Â type-ann-maybeÂ ([idÂ :Â tÂ init-expr]Â ...Â maybe-result)
Â Â (for-clauseÂ ...)
Â Â exprÂ ...+)
Â 
maybe-resultÂ =Â 
           Â Â |Â #:resultÂ result-expr
syntax
(for*Â void-ann-maybeÂ (for-clauseÂ ...)
Â Â exprÂ ...+)
syntax
(for*/listsÂ type-ann-maybeÂ ([idÂ :Â t]Â ...Â maybe-result)
Â Â (for-clauseÂ ...)
Â Â exprÂ ...+)
syntax
(for*/foldÂ Â type-ann-maybeÂ ([idÂ :Â tÂ init-expr]Â ...Â maybe-result)
Â Â (for-clauseÂ ...)
Â Â exprÂ ...+)
Â 
maybe-resultÂ =Â 
           Â Â |Â #:resultÂ result-expr
syntax
(doÂ :Â uÂ ([idÂ :Â tÂ init-exprÂ step-expr-maybe]Â ...)
Â Â Â Â Â Â Â Â (stop?-exprÂ finish-exprÂ ...)
Â Â exprÂ ...+)
Â 
step-expr-maybeÂ =Â 
              Â Â |Â step-expr
syntax
(defineÂ maybe-tvarsÂ vÂ maybe-annÂ e)
(defineÂ maybe-tvarsÂ headerÂ maybe-annÂ . body)
Â 
     headerÂ =Â (function-nameÂ . formals)
          Â Â |Â (headerÂ . formals)
          Â Â Â Â Â 
    formalsÂ =Â (formalÂ ...)
          Â Â |Â (formalÂ ...Â . rst)
          Â Â Â Â Â 
     formalÂ =Â var
          Â Â |Â [varÂ default-expr]
          Â Â |Â [varÂ :Â type]
          Â Â |Â [varÂ :Â typeÂ default-expr]
          Â Â |Â keywordÂ var
          Â Â |Â keywordÂ [varÂ :Â type]
          Â Â |Â keywordÂ [varÂ :Â typeÂ default-expr]
          Â Â Â Â Â 
        rstÂ =Â var
          Â Â |Â [varÂ :Â typeÂ *]
          Â Â |Â [varÂ :Â typeÂ oooÂ bound]
          Â Â Â Â Â 
maybe-tvarsÂ =Â 
          Â Â |Â #:forallÂ (tvarÂ ...)
          Â Â |Â #:âˆ€Â (tvarÂ ...)
          Â Â |Â #:forallÂ (tvarÂ ...Â ooo)
          Â Â |Â #:âˆ€Â (tvarÂ ...Â ooo)
          Â Â Â Â Â 
  maybe-annÂ =Â 
          Â Â |Â :Â type
syntax
(structÂ maybe-type-varsÂ name-specÂ ([fÂ :Â t]Â ...)Â optionsÂ ...)
Â 
maybe-type-varsÂ =Â 
              Â Â |Â (vÂ ...)
              Â Â Â Â Â 
      name-specÂ =Â name-id
              Â Â |Â name-idÂ parent
              Â Â Â Â Â 
        optionsÂ =Â #:transparent
              Â Â |Â #:mutable
              Â Â |Â #:prefab
              Â Â |Â #:constructor-nameÂ constructor-id
              Â Â |Â #:extra-constructor-nameÂ constructor-id
              Â Â |Â #:type-nameÂ type-id
syntax
(define-structÂ maybe-type-varsÂ name-specÂ ([fÂ :Â t]Â ...)Â optionsÂ ...)
Â 
maybe-type-varsÂ =Â 
              Â Â |Â (vÂ ...)
              Â Â Â Â Â 
      name-specÂ =Â name-id
              Â Â |Â name-idÂ parent
              Â Â Â Â Â 
        optionsÂ =Â #:transparent
              Â Â |Â #:mutable
              Â Â |Â #:type-nameÂ type-id
syntax
(define-struct/execÂ name-specÂ ([fÂ :Â t]Â ...)Â [eÂ :Â proc-t]Â maybe-type-name)
Â 
      name-specÂ =Â name-id
              Â Â |Â name-idÂ parent
              Â Â Â Â Â 
maybe-type-nameÂ =Â 
              Â Â |Â #:type-nameÂ type-id
syntax
(define-typeÂ nameÂ tÂ maybe-omit-def)
(define-typeÂ (nameÂ vÂ ...)Â tÂ maybe-omit-def)
Â 
maybe-omit-defÂ =Â #:omit-define-syntaxes
             Â Â |Â 
syntax
(make-predicateÂ t)
syntax
(define-predicateÂ nameÂ t)
syntax
(:Â vÂ t)
(:Â vÂ :Â t)
syntax
(provide:Â [vÂ t]Â ...)
syntax
#{vÂ :Â t}
syntax
(annÂ eÂ t)
syntax
#{eÂ ::Â t}
syntax
(castÂ eÂ t)
syntax
(instÂ eÂ tÂ ...)
(instÂ eÂ tÂ ...Â tÂ oooÂ bound)
syntax
(row-instÂ eÂ row)
syntax
#{eÂ @Â tÂ ...}
syntax
#{eÂ @Â tÂ ...Â tÂ oooÂ bound}
syntax
(require/typedÂ mÂ rt-clauseÂ ...)
Â 
    rt-clauseÂ =Â [maybe-renamedÂ t]
            Â Â |Â [#:structÂ maybe-tvarsÂ name-idÂ ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
            Â Â |Â [#:structÂ maybe-tvarsÂ (name-idÂ parent)Â ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
            Â Â |Â [#:opaqueÂ tÂ pred]
            Â Â |Â [#:signatureÂ nameÂ ([idÂ :Â t]Â ...)]
            Â Â Â Â Â 
maybe-renamedÂ =Â id
            Â Â |Â (orig-idÂ new-id)
            Â Â Â Â Â 
  maybe-tvarsÂ =Â 
            Â Â |Â (type-variableÂ ...)
            Â Â Â Â Â 
struct-optionÂ =Â #:constructor-nameÂ constructor-id
            Â Â |Â #:extra-constructor-nameÂ constructor-id
            Â Â |Â #:type-nameÂ type-id
syntax
(require/typed/provideÂ mÂ rt-clauseÂ ...)
syntax
with-handlers
procedure
(default-continuation-prompt-tag)
Â ->Â (->Â (Prompt-TagofÂ AnyÂ (AnyÂ ->Â Any)))
syntax
(#%module-beginÂ formÂ ...)
syntax
(#%top-interactionÂ . form)
type
GIF-Stream
type
GIF-Colormap
type
JSExpr
type
Cookie
type
Cookie
type
FTP-Connection
type
HTTP-Connection
type
IMAP-Connection
type
Path/Param
type
URL
type
URL-Exception
type
PortT
type
PortT/Bytes
type
SSL-Protocol
type
SSL-Server-Context
type
SSL-Client-Context
type
SSL-Context
type
SSL-Listener
type
SSL-Verify-Source
syntax
(for/extflvectorÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/extflvectorÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for/flvectorÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
syntax
(for*/flvectorÂ type-ann-maybeÂ (for-clauseÂ ...)Â exprÂ ...+)
type
Char-Set
type
Cursor
type
Time
type
Date
syntax
(classÂ superclass-expr
Â Â maybe-type-parameters
Â Â class-clauseÂ ...)
Â 
         class-clauseÂ =Â (inspectÂ inspector-expr)
                    Â Â |Â (initÂ init-declÂ ...)
                    Â Â |Â (init-fieldÂ init-declÂ ...)
                    Â Â |Â (init-restÂ id/type)
                    Â Â |Â (fieldÂ field-declÂ ...)
                    Â Â |Â (inherit-fieldÂ field-declÂ ...)
                    Â Â |Â (publicÂ maybe-renamed/typeÂ ...)
                    Â Â |Â (pubmentÂ maybe-renamed/typeÂ ...)
                    Â Â |Â (overrideÂ maybe-renamed/typeÂ ...)
                    Â Â |Â (augmentÂ maybe-renamed/typeÂ ...)
                    Â Â |Â (privateÂ id/typeÂ ...)
                    Â Â |Â (inheritÂ idÂ ...)
                    Â Â |Â method-definition
                    Â Â |Â definition
                    Â Â |Â expr
                    Â Â |Â (beginÂ class-clauseÂ ...)
                    Â Â Â Â Â 
maybe-type-parametersÂ =Â 
                    Â Â |Â #:forallÂ (type-variableÂ ...)
                    Â Â |Â #:âˆ€Â (type-variableÂ ...)
                    Â Â Â Â Â 
            init-declÂ =Â id/type
                    Â Â |Â [renamed]
                    Â Â |Â [renamedÂ :Â type-expr]
                    Â Â |Â [maybe-renamedÂ default-value-expr]
                    Â Â |Â [maybe-renamedÂ :Â type-exprÂ default-value-expr]
                    Â Â Â Â Â 
           field-declÂ =Â (maybe-renamedÂ default-value-expr)
                    Â Â |Â (maybe-renamedÂ :Â type-exprÂ default-value-expr)
                    Â Â Â Â Â 
              id/typeÂ =Â id
                    Â Â |Â [idÂ :Â type-expr]
                    Â Â Â Â Â 
   maybe-renamed/typeÂ =Â maybe-renamed
                    Â Â |Â [maybe-renamedÂ :Â type-expr]
                    Â Â Â Â Â 
        maybe-renamedÂ =Â id
                    Â Â |Â renamed
                    Â Â Â Â Â 
              renamedÂ =Â (internal-idÂ external-id)
syntax
(define/publicÂ idÂ expr)
(define/publicÂ (idÂ . formals)Â bodyÂ ...+)
syntax
(define/overrideÂ idÂ expr)
(define/overrideÂ (idÂ . formals)Â bodyÂ ...+)
syntax
(define/pubmentÂ idÂ expr)
(define/pubmentÂ (idÂ . formals)Â bodyÂ ...+)
syntax
(define/augmentÂ idÂ expr)
(define/augmentÂ (idÂ . formals)Â bodyÂ ...+)
syntax
(define/privateÂ idÂ expr)
(define/privateÂ (idÂ . formals)Â bodyÂ ...+)
syntax
(initÂ init-declÂ ...)
syntax
(init-fieldÂ init-declÂ ...)
syntax
(fieldÂ field-declÂ ...)
syntax
(inherit-fieldÂ field-declÂ ...)
syntax
(init-restÂ id/type)
syntax
(publicÂ maybe-renamed/typeÂ ...)
syntax
(pubmentÂ maybe-renamed/typeÂ ...)
syntax
(overrideÂ maybe-renamed/typeÂ ...)
syntax
(augmentÂ maybe-renamed/typeÂ ...)
syntax
(privateÂ id/typeÂ ...)
syntax
(inheritÂ maybe-renamed/typeÂ ...)
syntax
(ClassÂ class-type-clauseÂ ...)
Â 
class-type-clauseÂ =Â name+type
                Â Â |Â (initÂ init-typeÂ ...)
                Â Â |Â (init-fieldÂ init-typeÂ ...)
                Â Â |Â (init-restÂ name+type)
                Â Â |Â (fieldÂ name+typeÂ ...)
                Â Â |Â (augmentÂ name+typeÂ ...)
                Â Â |Â #:implementsÂ type-alias-id
                Â Â |Â #:implements/initsÂ inits-id
                Â Â |Â #:row-varÂ row-var-id
                Â Â Â Â Â 
        init-typeÂ =Â name+type
                Â Â |Â [idÂ typeÂ #:optional]
                Â Â Â Â Â 
        name+typeÂ =Â [idÂ type]
syntax
ClassTop
syntax
(ObjectÂ object-type-clauseÂ ...)
Â 
object-type-clauseÂ =Â name+type
                 Â Â |Â (fieldÂ name+typeÂ ...)
syntax
(InstanceÂ class-type-expr)
syntax
(RowÂ class-type-clauseÂ ...)
syntax
(define-signatureÂ idÂ extension-decl
Â Â (sig-elemÂ ...))
Â 
extension-declÂ =Â 
             Â Â |Â extendsÂ sig-id
             Â Â Â Â Â 
      sig-elemÂ =Â [idÂ :Â type]
syntax
(unit
Â Â (importÂ sig-specÂ ...)
Â Â (exportÂ sig-specÂ ...)
Â Â init-depends-decl
Â Â unit-body-expr-or-defn
Â Â ...)
Â 
         sig-specÂ =Â sig-id
                Â Â |Â (prefixÂ idÂ sig-spec)
                Â Â |Â (renameÂ sig-specÂ (idÂ id)Â ...)
                Â Â |Â (onlyÂ sig-specÂ idÂ ...)
                Â Â |Â (exceptÂ sig-specÂ idÂ ...)
                Â Â Â Â Â 
init-depends-declÂ =Â 
                Â Â |Â (init-dependÂ sig-idÂ ...)
syntax
(invoke-unitÂ unit-expr)
(invoke-unitÂ unit-exprÂ (importÂ sig-specÂ ...))
syntax
(define-values/invoke-unitÂ unit-expr
Â Â (importÂ def-sig-specÂ ...)
Â Â (exportÂ def-sig-specÂ ...))
Â 
def-sig-specÂ =Â sig-id
           Â Â |Â (prefixÂ idÂ def-sig-spec)
           Â Â |Â (renameÂ def-sig-specÂ (idÂ id)Â ...)
syntax
(compound-unit
Â Â (importÂ link-bindingÂ ...)
Â Â (exportÂ link-idÂ ...)
Â Â (linkÂ linkage-declÂ ...))
Â 
link-bindingÂ =Â (link-idÂ :Â sig-id)
           Â Â Â Â Â 
linkage-declÂ =Â ((link-bindingÂ ...)Â unit-exprÂ link-idÂ ...)
syntax
(define-unitÂ unit-id
Â Â (importÂ sig-specÂ ...)
Â Â (exportÂ sig-specÂ ...)
Â Â init-depends-decl
Â Â unit-body-expr-or-defn
Â Â ...)
syntax
(compound-unit/infer
Â Â (importÂ infer-link-importÂ ...)
Â Â (exportÂ infer-link-exportÂ ...)
Â Â (linkÂ infer-linkage-declÂ ...))
Â 
 infer-link-importÂ =Â sig-id
                 Â Â |Â (link-idÂ :Â sig-id)
                 Â Â Â Â Â 
 infer-link-exportÂ =Â link-id
                 Â Â |Â sig-id
                 Â Â Â Â Â 
infer-linkage-declÂ =Â ((link-bindingÂ ...)Â unit-id
                     Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â tagged-link-idÂ ...)
                 Â Â |Â unit-id
syntax
(define-compound-unitÂ id
Â Â (importÂ link-bindingÂ ...)
Â Â (exportÂ link-idÂ ...)
Â Â (linkÂ linkage-declÂ ...))
syntax
(define-compound-unit/inferÂ id
Â Â (importÂ link-bindingÂ ...)
Â Â (exportÂ infer-link-exportÂ ...)
Â Â (linkÂ infer-linkage-declÂ ...))
syntax
(invoke-unit/inferÂ unit-spec)
Â 
unit-specÂ =Â unit-id
        Â Â |Â (linkÂ link-unit-idÂ ...)
syntax
(define-values/invoke-unit/inferÂ maybe-exportsÂ unit-spec)
Â 
maybe-exportsÂ =Â 
            Â Â |Â (exportÂ sig-sepcÂ ...)
            Â Â Â Â Â 
    unit-specÂ =Â unit-id
            Â Â |Â (linkÂ link-unit-idÂ ...)
syntax
(unit-from-contextÂ sig-spec)
syntax
(define-unit-from-contextÂ idÂ sig-spec)
syntax
(Unit
Â Â (importÂ sig-idÂ ...)
Â Â (exportÂ sig-idÂ ...)
Â Â optional-init-depend-clause
Â Â optional-body-type-clause)
Â 
optional-init-depend-clauseÂ =Â 
                          Â Â |Â (init-dependÂ sig-idÂ ...)
                          Â Â Â Â Â 
  optional-body-type-clauseÂ =Â 
                          Â Â |Â type
                          Â Â |Â (ValuesÂ typeÂ ...)
syntax
UnitTop
syntax
(require/typedÂ mÂ rt-clauseÂ ...)
Â 
    rt-clauseÂ =Â [maybe-renamedÂ t]
            Â Â |Â [#:structÂ nameÂ ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
            Â Â |Â [#:structÂ (nameÂ parent)Â ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
            Â Â |Â [#:opaqueÂ tÂ pred]
            Â Â |Â [#:signatureÂ nameÂ ([idÂ :Â t]Â ...)]
            Â Â Â Â Â 
maybe-renamedÂ =Â id
            Â Â |Â (orig-idÂ new-id)
            Â Â Â Â Â 
struct-optionÂ =Â #:constructor-nameÂ constructor-id
            Â Â |Â #:extra-constructor-nameÂ constructor-id
procedure
(assertÂ v)Â ->Â A
Â Â vÂ :Â (UÂ #fÂ A)
(assertÂ vÂ p?)Â ->Â B
Â Â vÂ :Â A
Â Â p?Â :Â (AÂ ->Â AnyÂ :Â B)
syntax
(with-assertsÂ ([idÂ maybe-pred]Â ...)Â bodyÂ ...+)
Â 
maybe-predÂ =Â 
         Â Â |Â predicate
procedure
(defined?Â v)Â ->Â boolean?
Â Â vÂ :Â any/c
procedure
(index?Â v)Â ->Â boolean?
Â Â vÂ :Â any/c
syntax
(typecheck-failÂ orig-stxÂ maybe-msgÂ maybe-id)
Â 
maybe-msgÂ =Â 
        Â Â |Â msg-string
        Â Â Â Â Â 
 maybe-idÂ =Â 
        Â Â |Â #:covered-idÂ id
syntax
(assert-typecheck-failÂ body-expr)
(assert-typecheck-failÂ body-exprÂ #:resultÂ result-expr)
syntax
(require/untyped-contractÂ maybe-beginÂ moduleÂ [nameÂ subtype]Â ...)
Â 
maybe-beginÂ =Â 
          Â Â |Â (beginÂ exprÂ ...)
syntax
(define-typed/untyped-identifierÂ nameÂ typed-nameÂ untyped-name)
procedure
(syntax-local-typed-context?)Â ->Â boolean?
syntax
(:typeÂ maybe-verboseÂ t)
Â 
maybe-verboseÂ =Â 
            Â Â |Â #:verbose
syntax
(:print-typeÂ e)
syntax
(:query-type/argsÂ fÂ tÂ ...)
syntax
(:query-type/resultÂ fÂ t)
syntax
(with-typeÂ result-specÂ fv-clauseÂ bodyÂ ...+)
(with-typeÂ export-specÂ fv-clauseÂ bodyÂ ...+)
Â 
  fv-clauseÂ =Â 
          Â Â |Â #:freevarsÂ ([idÂ fv-type]Â ...)
          Â Â Â Â Â 
result-specÂ =Â #:resultÂ type
          Â Â Â Â Â 
export-specÂ =Â ([export-idÂ export-type]Â ...)
syntax
(unsafe-require/typedÂ mÂ rt-clauseÂ ...)
syntax
(unsafe-provideÂ provide-specÂ ...)
syntax
(unsafe-require/typed/provideÂ mÂ rt-clauseÂ ...)
syntax
(lambda:Â formalsÂ . body)
Â 
formalsÂ =Â ([vÂ :Â t]Â ...)
      Â Â |Â ([vÂ :Â t]Â ...Â vÂ :Â tÂ *)
      Â Â |Â ([vÂ :Â t]Â ...Â vÂ :Â tÂ oooÂ bound)
syntax
(Î»:Â formalsÂ . body)
syntax
(plambda:Â (aÂ ...)Â formalsÂ . body)
(plambda:Â (aÂ ...Â bÂ ooo)Â formalsÂ . body)
syntax
(opt-lambda:Â formalsÂ . body)
Â 
formalsÂ =Â ([vÂ :Â t]Â ...Â [vÂ :Â tÂ default]Â ...)
      Â Â |Â ([vÂ :Â t]Â ...Â [vÂ :Â tÂ default]Â ...Â vÂ :Â tÂ *)
      Â Â |Â ([vÂ :Â t]Â ...Â [vÂ :Â tÂ default]Â ...Â vÂ :Â tÂ oooÂ bound)
syntax
(popt-lambda:Â (aÂ ...)Â formalsÂ . body)
(popt-lambda:Â (aÂ ...Â aÂ ooo)Â formalsÂ . body)
syntax
case-lambda:
syntax
(pcase-lambda:Â (aÂ ...)Â [formalsÂ body]Â ...)
(pcase-lambda:Â (aÂ ...Â bÂ ooo)Â [formalsÂ body]Â ...)
syntax
(let:Â ([vÂ :Â tÂ e]Â ...)Â . body)
(let:Â loopÂ :Â t0Â ([vÂ :Â tÂ e]Â ...)Â . body)
syntax
(plet:Â (aÂ ...)Â ([vÂ :Â tÂ e]Â ...)Â . body)
syntax
(letrec:Â ([vÂ :Â tÂ e]Â ...)Â . body)
syntax
(let*:Â ([vÂ :Â tÂ e]Â ...)Â . body)
syntax
(let-values:Â ([([vÂ :Â t]Â ...)Â e]Â ...)Â . body)
syntax
(letrec-values:Â ([([vÂ :Â t]Â ...)Â e]Â ...)Â . body)
syntax
(let*-values:Â ([([vÂ :Â t]Â ...)Â e]Â ...)Â . body)
syntax
(let/cc:Â vÂ :Â tÂ . body)
syntax
(let/ec:Â vÂ :Â tÂ . body)
syntax
(define:Â vÂ :Â tÂ e)
(define:Â (aÂ ...)Â vÂ :Â tÂ e)
(define:Â (aÂ ...Â aÂ ooo)Â vÂ :Â tÂ e)
(define:Â (fÂ . formals)Â :Â tÂ . body)
(define:Â (aÂ ...)Â (fÂ . formals)Â :Â tÂ . body)
(define:Â (aÂ ...Â aÂ ooo)Â (fÂ . formals)Â :Â tÂ . body)
syntax
struct:
syntax
define-struct:
syntax
define-struct/exec:
syntax
for:
syntax
for*/and:
syntax
for*/first:
syntax
for*/flvector:
syntax
for*/extflvector:
syntax
for*/fold:
syntax
for*/hash:
syntax
for*/hasheq:
syntax
for*/hasheqv:
syntax
for*/last:
syntax
for*/list:
syntax
for*/lists:
syntax
for*/set:
syntax
for*/or:
syntax
for*/product:
syntax
for*/sum:
syntax
for*/vector:
syntax
for*:
syntax
for/and:
syntax
for/first:
syntax
for/flvector:
syntax
for/extflvector:
syntax
for/fold:
syntax
for/hash:
syntax
for/hasheq:
syntax
for/hasheqv:
syntax
for/last:
syntax
for/list:
syntax
for/lists:
syntax
for/set:
syntax
for/or:
syntax
for/product:
syntax
for/sum:
syntax
for/vector:
syntax
do:
syntax
define-type-alias
syntax
define-typed-struct
syntax
require/opaque-type
syntax
require-typed-struct
syntax
require-typed-struct/provide
syntax
pdefine:
syntax
(predÂ t)
syntax
Un
syntax
mu
syntax
Tuple
syntax
Parameter
syntax
Pair
syntax
values
syntax
(require/typedÂ mÂ rt-clauseÂ ...)
Â 
    rt-clauseÂ =Â [rÂ t]
            Â Â |Â [structÂ nameÂ ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
            Â Â |Â [structÂ (nameÂ parent)Â ([fÂ :Â t]Â ...)
                Â Â Â Â Â struct-optionÂ ...]
            Â Â |Â [opaqueÂ tÂ pred]
            Â Â Â Â Â 
struct-optionÂ =Â #:constructor-nameÂ constructor-id
            Â Â |Â #:extra-constructor-nameÂ constructor-id
syntax
require-typed-struct
syntax
(declare-refinementÂ id)
syntax
(RefinementÂ id)
syntax
(define-typed-struct/execÂ formsÂ ...)
syntax
(define-new-subtypeÂ nameÂ (constructorÂ t))
syntax
(RefineÂ [idÂ :Â type]Â proposition)
Â 
    propositionÂ =Â Top
              Â Â |Â Bot
              Â Â |Â (:Â symbolic-objectÂ type)
              Â Â |Â (!Â symbolic-objectÂ type)
              Â Â |Â (andÂ propositionÂ ...)
              Â Â |Â (orÂ propositionÂ ...)
              Â Â |Â (whenÂ propositionÂ proposition)
              Â Â |Â (unlessÂ propositionÂ proposition)
              Â Â |Â (ifÂ propositionÂ propositionÂ proposition)
              Â Â |Â (linear-compÂ symbolic-objectÂ symbolic-object)
              Â Â Â Â Â 
    linear-compÂ =Â <
              Â Â |Â <=
              Â Â |Â =
              Â Â |Â >=
              Â Â |Â >
              Â Â Â Â Â 
symbolic-objectÂ =Â exact-integer
              Â Â |Â symbolic-path
              Â Â |Â (+Â symbolic-objectÂ ...)
              Â Â |Â (-Â symbolic-objectÂ ...)
              Â Â |Â (*Â exact-integerÂ symbolic-object)
              Â Â Â Â Â 
  symbolic-pathÂ =Â id
              Â Â |Â (path-elemÂ symbolic-path)
              Â Â Â Â Â 
      path-elemÂ =Â car
              Â Â |Â cdr
              Â Â |Â vector-length
syntax
(!Â sym-objÂ type)
syntax
(->Â ([idÂ :Â opt-depsÂ arg-type]Â ...)
Â Â Â Â opt-pre
Â Â Â Â range-type
Â Â Â Â opt-props)
Â 
    opt-depsÂ =Â 
           Â Â |Â (idÂ ...)
           Â Â Â Â Â 
     opt-preÂ =Â 
           Â Â |Â #:preÂ (idÂ ...)Â prop
           Â Â Â Â Â 
   opt-propsÂ =Â 
           Â Â |Â opt-pos-propÂ opt-neg-propÂ opt-obj
           Â Â Â Â Â 
opt-pos-propÂ =Â 
           Â Â |Â #:+Â prop
           Â Â Â Â Â 
opt-neg-propÂ =Â 
           Â Â |Â #:-Â prop
           Â Â Â Â Â 
     opt-objÂ =Â 
           Â Â |Â #:objectÂ obj
